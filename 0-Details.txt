How Dart Runs:
    Dart can run in two main ways:
        1- Ahead-of-Time (AOT) Compilation → For fast native mobile/desktop apps
            AOT means the Dart code is compiled to native machine code before the app is run.
            Where is AOT Used?
                - In production builds
                - When you create a release app for Android, iOS, Windows, etc.
        2- Just-in-Time (JIT) Compilation → Used in development for hot reload
            JIT stands for Just-in-Time compilation. Dart code is compiled at runtime, 
            while the app is running.
            Where is JIT Used?
                - During development
                - When you're using Flutter hot reload or hot restart
    In this repo:
        Your Dart programs run in JIT mode (standard run) and later understand AOT conceptually
        for future use (When You Shift to Flutter).
--------------------------------------------------------------------------------------------
Function Related Questions:
---------------------------
What are the different ways to define functions in Dart?
    --> Standard Named Function (required parameter function if declare)
    --> Arrow Function (Shorthand)
    --> Anonymous Function (Lambda)
    --> Function Expression Stored in a Variable
        e.g:
            Function greet = () => print("Hello");
--------
What is the difference between named and positional parameters?
    --> Positional Parameters:
        - Use square brackets [].
        - Order matters.
        - Arguments name optional.
        e.g:
            void greet(String name, [String title = 'Mr.']) {
                print('Hello $title $name');
            }
            greet('Ali'); // Hello Mr. Ali
    --> Named Parameters:
        - Use curly braces {}.
        - Can be passed in any order.
        - Can be optional (with default) or required (with required).
        e.g:
            void greet({required String name, String title = 'Mr.'}) {
                print('Hello $title $name');
            }
            greet(name: 'Ali'); // Hello Mr. Ali
--------
What is a closure in Dart?
    A closure is a function that captures variables from its surrounding lexical scope, even 
    after the outer function has finished executing.
    example:
        Function makeAdder(int x) {
            return (int y) => x + y; // x is captured
        }
        var add2 = makeAdder(2);
        print(add2(3)); // 5

    - x remains in memory because it’s used inside the returned function.
--------
How does Dart treat functions as first-class objects?
    In Dart:
        Functions can be assigned to variables.
        Functions can be passed as arguments.
        Functions can be returned from other functions.
--------
What are function tear-offs and when would you use them?
    A function tear-off is a way to refer to a function by name without calling it.
    Use Case:
        You want to pass a function as a reference, not call it.
--------
What is the difference between sync* and async* generators?
    Both return a sequence of values over time using yield.
        | Feature  | `sync*`                | `async*`                            |
        | -------- | ---------------------- | ----------------------------------- |
        | Returns  | `Iterable<T>`          | `Stream<T>`                         |
        | Use case | Synchronous iteration  | Asynchronous (with delays, futures) |
        | Usage    | `for (var x in foo())` | `await for (var x in foo())`        |
        - sync* example:
            Iterable<int> getNumbers() sync* {
                yield 1;
                yield 2;
            }
        - async* example:
            Stream<int> getNumbers() async* {
                await Future.delayed(Duration(seconds: 1));
                yield 1;
                yield 2;
            }
--------------------------------------------------------------------------------------------
Interfaces Related Questions:
----------------------------
--> Why Would You Use implements Over extends?
  Reason:
    You use implements when:
      - You want to use only the structure of a class (its method signatures) and 
        not inherit behavior.
      - You want to implement multiple interfaces, which extends does not allow.
      - You want complete control over the implementation.
--------------------------------------------------------------------------------------------

